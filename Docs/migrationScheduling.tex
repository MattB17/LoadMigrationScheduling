\documentclass[conference]{IEEEtran}
% \documentclass[journal]{IEEEtran}
% \documentclass[12pt, draftclsnofoot, onecolumn]{IEEEtran}
% \documentclass[draftclsnofoot, onecolumn]{IEEEtran} 
% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
  % \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi


% Soheil: for coloring tables
\usepackage{color, colortbl}
\definecolor{Gray}{gray}{0.9}
\definecolor{LightCyan}{rgb}{0.88,1,1}
\definecolor{LightRed}{rgb}{1,0.88,0.88}
\definecolor{LightBlue}{rgb}{0.12,0.56,0.8}
\usepackage[table]{xcolor}% http://ctan.org/pkg/xcolor
\usepackage[first=0,last=9]{lcg}
\usepackage{xfrac} % http://ctan.org/pkg/xfrac







\usepackage[english]{babel}
\usepackage{blindtext}

\usepackage{subcaption}
% \DeclareMathOperator{\E}{\mathbb{E}}
\usepackage{algorithm}
\usepackage{algorithmic}
%\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{chngcntr}
\usepackage{enumitem}
\usepackage{mathtools}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{lipsum}

%\floatname{algorithm}{Procedure}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
% \usepackage{xcolor}

%\usepackage[title]{appendix}

\newcommand{\etal}{\textit{et al}.}
\usepackage{multicol}
\usepackage{multirow}

\usepackage{colortbl}
\definecolor{White}{gray}{1}
\definecolor{Gray}{gray}{0.9}
\definecolor{black}{gray}{0.6}
\definecolor{Orange}{RGB}{255,153,100}
\definecolor{Bluee}{RGB}{225,250,255}
\definecolor{Blue}{RGB}{185,210,255}
\definecolor{Blu}{RGB}{145,170,255}
\definecolor{Bl}{RGB}{110,135,255}
%\definecolor{Blue}{RGB}{180,200,255}
%\definecolor{Blu}{RGB}{130,153,255}
%\definecolor{Bl}{RGB}{80,130,255}
\definecolor{Green}{RGB}{130,255,130}
\definecolor{Purple}{RGB}{183,130,255}
\definecolor{LightRed}{rgb}{1,0.3,.3}
\definecolor{LightGreen}{rgb}{0.26,1,0.6}
\definecolor{LightBlue}{rgb}{0.26,0.6,1}
\definecolor{ACMLightBlue}{cmyk}{0.49,0.01,0,0}
\newcolumntype{g}{>{\columncolor{Gray}}c}
\newcolumntype{w}{>{\columncolor{Bluee}}c}
\newcolumntype{d}{>{\columncolor{Bluee}}l}
\newcolumntype{b}{>{\columncolor{Blue}}c}
\newcolumntype{r}{>{\columncolor{Blu}}c}

\usepackage{balance}

% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}

\newtheorem{theorem}{Theorem}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}


\begin{document}
\title{Switch Migration Scheduling in Distributed SDN Controllers}

\author{Some Guys!}
% \author{\IEEEauthorblockN{1\textsuperscript{st} Given Name Surname}
% \IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID}
% \and
% \IEEEauthorblockN{2\textsuperscript{nd} Given Name Surname}
% \IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID}
% \and
% \IEEEauthorblockN{3\textsuperscript{rd} Given Name Surname}
% \IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
% \textit{name of organization (of Aff.)}\\
% City, Country \\
% email address or ORCID}
% }

% make the title area
\maketitle

\begin{abstract}
\blindtext
\end{abstract}

\begin{IEEEkeywords}
Load Migration, Scheduling, Optimization
\end{IEEEkeywords}

\IEEEpeerreviewmaketitle

\section{Formulation}

\noindent It is assumed that the migrations take place in a series of discrete rounds. That is, in each round a collection of migrations occur, respecting the controller resource and QoS constraints. Then these migrations are removed from consideration for subsequent rounds. Our goal is to complete all migrations in the minimum number of rounds. We assume that at most $R$ rounds are needed. We discuss later how to find such a value $R$.

To model this, we consider an Integer Linear Program (ILP). It is assumed that we have $k$ controllers $\mathcal{C} = \{c_{0}, ..., c_{k-1}\}$. Controller $c_{j}$ can handle a load of $\alpha_{j}$ per round. In addition, there are $n$ switches $\mathcal{S} = \{s_{0}, ..., s_{n-1}\}$

There are a set of $p$ migrations $\mathcal{M} = \{m_{0}, ..., m_{p-1}\}$. For $i \in \{0, ..., p-1\}$, migration $m_{i}$ migrates switch $s_{h_{i}}$ from controller $c_{src_{i}}$ to $c_{dst_{i}}$ where $h_{i} \in \{0, 1, ..., n - 1\}$ and $src_{i}, dst_{i} \in \{0, 1, ..., k - 1\}$ with $src_{i} \neq dst_{i}$. Moreover, the migration requires $w_{i}$ units of controller resources. 

We add the additional assumption that $s_{h_{0}}, ..., s_{h_{p-1}}$ are all distinct. This excludes the case that we have a switch $s$ that is migrated from controller $a$ to controller $b$ and then later migrated from controller $b$ to controller $c$. Instead, we would just specify a single migration from controller $a$ to $c$. Note, with this constraint, we have that $p \leq n$. For ease of exposition, we can then relabel the switches so that migration $i$ takes place for switch $s_{i}$ and then we can assume $p = n$ (any switch not involved in a migration does not contribute to the model and can thus be ignored).

There are also a set of $q$ groups $\mathcal{G} = \{g_{0}, ..., g_{q-1}\}$. For $l \in \{0, 1, ..., q - 1\}$, group $g_{l}$ is a set of switches associated with a particular QoS constraint such as a specific service or a critical network path. Group $g_{l}$ has a capacity $\beta_{l}$ specifying a limit on the number of switches in $g_{l}$ which can be migrated in one round.

\begin{table}[]
    \centering
    \begin{tabular}{||p{1.3cm}|p{6cm}||}
        \hline
        Parameter & Description \\
        \hline\hline
        $\mathcal{C}$ & set of controllers \\
        \hline
        $\alpha_{j}$ & maximum per-round load on controller $c_{j} \in \mathcal{C}$ \\
        \hline
        $\delta^{src}_{j}$ & the set of migrations having $c_{j} \in \mathcal{C}$ as source controller \\
        \hline
        $\delta^{dst}_{j}$ & the set of migrations having $c_{j} \in \mathcal{C}$ as destination controller \\
        \hline
        $\mathcal{S}$ & set of switches \\
        \hline
        $\mathcal{M}$ & set of migrations \\
        \hline
        $c_{src_{i}}$ & source controller for migration $i$ \\
        \hline
        $c_{dst_{i}}$ & destination controller for migration $i$ \\
        \hline
        $w_{i}$ & load incurred to perform migration $i$ \\
        \hline
        $\mathcal{G}$ & set of QoS groups \\
        \hline
        $\beta_{l}$ & maximum per-round migrations for group $g_{l} \in \mathcal{G}$ \\
        \hline
    \end{tabular}
    \caption{Parameter Definitions}
    \label{tbl:defs}
\end{table}

The set of parameters are specified in Table \ref{tbl:defs}.

\noindent\textbf{Variables}
\noindent As mentioned previously, we assume we have an upper bound $R$ on the number of rounds required for all migrations. Thus we introduce binary variables $x^{r}_{i}$ for $i \in \{0, 1, ..., n - 1\}$ and $r \in \{0, 1, ..., R - 1\}$ where
\[
    x^{r}_{i} =
    \begin{cases}
        1 &\text{ if migration } i \text { is scheduled in round } r \\
        0 &\text{ otherwise}
    \end{cases}
\]

\noindent\textbf{Constraints}
\noindent Each migration $i \in \{0, 1, ..., n - 1\}$ must take place in exactly one round. $x^{r}_{i}$ is 1 precisely when migration $i$ occurs in round $r \in \{0, 1, ..., R-1\}$ and 0 otherwise. Thus, we have

\begin{equation}\label{eq:single-migration}
    \sum_{r=0}^{R-1} x^{r}_{i} = 1 \hspace{1cm} \forall \, i \in \{0, 1, ..., n - 1\}
\end{equation}

\noindent For a controller $c_{j}$, $j \in \{0, 1, ..., k - 1\}$, let 

$$\delta^{dst}_{j} = \{i \, | \, i \in \{0, 1, ..., n-1\}, \, j = dst_{i}\}$$

That is, $\delta^{dst}_{j}$ is the set of migrations that have $c_{j}$ as the destination controller. In any round, the total load on controller $c_{j}$ from migrations cannot exceed $\alpha_{j}$ and if migration $i$ happens in round $r$ it contributes $w_{i}$ towards this load and 0 otherwise. Thus, it contributes $w_{i}x^{r}_{i}$ in round $r$. This gives the following constraint

\begin{equation}\label{eq:controller-simple}
    \sum_{i \, \in \, \delta^{in}_{j}} w_{i}x^{r}_{i} \leq \alpha_{j} \forall \, r \in \{0, ..., R-1\}, \, j \in \{0, ..., k-1\}
\end{equation}

If we want to add failure resiliency, we can also ensure that the load on the source controllers never exceeds their capacity. So we similarly define

$$\delta^{src}_{j} = \{i \, | \, i \in \{0, 1, ..., n-1\}, \, c_{j} = src_{i} i\}$$

So $\delta^{src}_{j}$ is the set of migrations that have $c_{j}$ as the source controller. Using the same logic, and updating equation (\ref{eq:controller-simple}) we get

\begin{equation}\label{eq:controller-extended}
\begin{split}
    &\sum_{i \, \in \, \delta^{out}_{j}} w_{i}x^{r}_{i} + \sum_{i \, \in \, \delta^{in}_{j}} w_{i}x^{r}_{i} \leq \alpha_{j} \\
    &\forall \, r \in \{0, ..., R-1\}, \, j \in \{0, ..., k-1\}
\end{split}
\end{equation}

Note that for a particular controller $c_{j}$, for any migration $i \in \{0, 1, ..., n-1\}$, $i$ is an element of at most one of $\delta^{src}_{j}$ and $\delta^{dst}_{j}$. Thus, the term $w_{i}x^{r}_{i}$ appears at most once in equation (\ref{eq:controller-extended}).

\noindent For a QoS group $g_{l}$, $l \in \{0, 1, ..., q-1\}$, at most $\beta_{l}$ of the migrations in this group can occur in a single round. Using the definition of the $x$ variables we have

\begin{equation}\label{eq:qos-constraint}
    \sum_{i \, \in \, g_{l}} x^{r}_{i} \leq \beta_{l} \hspace{1cm} \forall \, r \in \{0, ..., R - 1\}, \, l \in \{0, ..., q-1\}
\end{equation}

\noindent\textbf{Objective}
We want to minimize the maximum number of rounds to complete all migrations. So consider the quantity $r \cdot x^{r}_{i}$ for any $r \in \{0, ..., R - 1\}$ and $i \in \{0, ..., n - 1\}$. This quantity takes value $r$ when migration $i$ occurs in round $r$ and 0 otherwise. Thus, the quantity we want to minimize is

$$\max_{\substack{0 \leq i \leq n - 1 \\ 0 \leq r \leq R - 1}} r  \cdot x^{r}_{i}$$

Unfortunately, this quantity is not linear. In order to linearize it, we introduce a new variable $\lambda$ and introduce the constraints

\begin{equation}\label{eq:max-constraint}
    r \cdot x^{r}_{i} \leq \lambda \hspace{1cm} \forall \, i \in \{0, ..., n-1\}, \, r \in \{0, ..., R - 1\}
\end{equation}

With these new constraints, our objective simply becomes to minimize $\lambda$.

\noindent\textbf{Model}
\noindent Combining our objective function with the constraints given by (\ref{eq:single-migration}), (\ref{eq:controller-simple}), (\ref{eq:qos-constraint}), (\ref{eq:max-constraint}), and the binary constraints for our variables gives us our ILP model (P).\newline

\begin{minipage}{0.4\textwidth}
\begin{center}
    $\min$ $\lambda$
\end{center}
\end{minipage}
\begin{minipage}{0.05\textwidth}
\begin{center}
    ($P$)
\end{center}
\end{minipage}
s.t.
\begin{center}
    \begin{alignat*}{2}
        &\sum_{r=0}^{R-1} x^{r}_{i} = 1 \hspace{1cm} &&\forall \, i \in \{0, ..., n-1\} \\
        &\sum_{i \, \in \, \delta^{in}_{j}} w_{i}x^{r}_{i} \leq \alpha_{j} &&\forall \, r \in \{0, ..., R-1\}, \, j \in \{0, ..., k-1\}\\
        &\sum_{i \, \in \, g_{l}} x^{r}_{i} \leq \beta_{l} &&\forall \, r \in \{0, ..., R-1\}, l\,  \in \{0, ..., q-1\}\\
        &r(x^{r}_{i}) \leq \lambda &&\forall \, i \in \{0, ..., n - 1\}, \, r \in \{0, ..., R - 1\}\\
        &x^{r}_{i} \in \{0, 1\} &&\forall \, i \in \{0, ..., n - 1\}, \, r \in \{0, ..., R - 1\}
    \end{alignat*}
\end{center}

\vskip 0.5cm

\section{Complexity}
In this section we show the hardness of the migration scheduling problem. Towards that end, consider a graph\newline $G=(V, E)$ where $V$ is the set of vertices and $E$ is the set of edges. 

For any $p \in \mathbb{Z}$, the set $\mathbb{Z}_{p}$ represents the set of integers modulo $p$. That is, $\mathbb{Z}_{p} = \{0, 1, ..., p - 1\}$. A valid $p$-colouring of $G$ is a function $f: V \rightarrow \mathbb{Z}_{p}$ such that for any $u, v \in V$ such that $uv \in E$, $f(u) \neq f(v)$. This corresponds to assigning colours to vertices such that no edge has its two endpoints assigned the same colour. Karp \cite{karp1972reducibility} showed that it is NP-complete to decide whether a given graph $G$ has a $p$-colouring for any $p \geq 3$ (note that graphs with a 1-colouring are an independent set and graphs with a 2-colouring are bipartite).

The chromatic number of $G$, denoted $\chi(G)$ is the minimum $p$ such that $G$ has a $p$-colouring. Note that finding $\chi(G)$ is also NP-complete because if we know $\chi(G)$ then we can answer whether or not $G$ has a $p$-colouring in constant time for any $p \in \mathbb{N}$. Given this, we now prove the following.

\begin{theorem}
    The migration scheduling problem is NP-hard.
\end{theorem}
\begin{proof}
    Consider a graph $G = (V, E)$ and suppose we want to determine $\chi(G)$. We will construct a migration scheduling instance as follows. \footnote{Note that we just have to show that solving a particular instance of load migration scheduling allows us to find the chromatic number of $G$ in polynomial time using this solution. To see this, suppose we had an oracle $A$ that solved any instance of the load migration scheduling problem. Then, in particular, $A$ can solve our specific instance to get a solution $S^{*}$. Using $S^{*}$ we can find the chromatic number of $G$ in polynomial time. As finding the chromatic number is NP-complete, oracle $A$ cannot run in polynomial time, as otherwise we could find the chromatic number of any $G$ in polynomial time by solving the constructed instance.} We have 2 controllers, $c_{0}$ and $c_{1}$ as well as $n = |V|$ switches and $n$ migrations. We relabel the vertices so that $V = \{0, 1, ..., n-1\}$ and then vertex $i$ is associated with a switch $s_{i}$ and migration $m_{i}$. Each migration has $c_{0}$ as the source controller and $c_{1}$ as the destination controller and a load of $w_{i} = 1$. Controller $c_{0}$ can accommodate a load of $\alpha_{0} = n$. Similarly, $\alpha_{1} = n$. So in the absence of QoS groups, all migrations can happen in one round.
    
    But now consider an edge $ij \in E$ ($i, j \in \{0, 1, ..., n - 1\}$ with $i \neq j$). We define a QoS group $g_{ij} = \{i, j\}$ with $\beta_{ij} = 1$. That is, there is a QoS group associated with each edge where the group contains the migrations corresponding to the endpoints of the edge. Moreover, $\beta_{ij} = 1$ enforces that the two migrations must complete in different rounds.
    
    This gives $|E|$ QoS groups and we have $|V|$ switches. With the addition of the 2 controllers this gives us a migration scheduling instance which has size $O(|V| + |E|)$.
    
    Now suppose we solve this instance to get an optimal solution $r*$ and define a function $f: V \rightarrow \mathbb{Z}_{r* + 1}$ such that for $i \in V$, $f(i) = r$ if migration $i$ happens in round $r$ with $0 \leq r \leq r*$. Consider any edge $ij \in E$. Then QoS group $g_{ij}$ ensures that migrations $i$ and $j$ complete in different rounds, say rounds $r_{1}$ and $r_{2}$ with $r_{1} \neq r_{2}$. Then by the definition of $f$ we have $f(i) = r_{1} \neq r_{2} = f(j)$. Thus, the ends of $ij$ receive different colours. As this is true for every edge of $G$, this gives a valid $(r* + 1)$-colouring of $G$.
    
    Thus, $\chi(G) \leq r* + 1$. We claim that $\chi(G) = r* + 1$. To see this, suppose as a contradiction that $\chi(G) < r* + 1$. Then $\exists p \in \mathbb{Z}$ with $p \leq r*$ such that $G$ has a $p$-colouring. Choose such a $p$ colouring $h: V \rightarrow \mathbb{Z}_{p}$. Then consider the following migration schedule: for each migration $i \in \{0, 1, ..., n-1\}$ if $h(i) = r \in \mathbb{Z}_{p}$ then we schedule migration $i$ in round $r$. Then note that all migrations are scheduled within the rounds 0 to $\max_{0 \leq i \leq n-1} h(i) \leq p - 1$. Also, there are $n$ nodes, so there are at most $n$ migrations in a single round, meaning the controller capacity constraints are trivially satisfied. Next consider the QoS constraints for a QoS group $g_{ij}$. Then $ij \in E$ and because $h$ is a valid colouring we have that $h(i) \neq h(j)$. So migrations $i$ and $j$ are scheduled in different rounds. That is, at most one migration of $g_{ij}$ is scheduled in each round. As $\beta_{ij} = 1$, the QoS constraints are valid. Thus, we have constructed a valid schedule that completes in at most $k - 1 < r*$ rounds, contradicting the optimality of $r*$.
    
    Thus, we have shown a complete reduction from finding the chromatic number of a graph $G$ to our problem. As determining $\chi(G)$ is NP-complete we have that the migration scheduling problem is NP-hard. 
\end{proof}

\section{Feasibility and Bounds}
\noindent We next consider the feasibility of the migration scheduling problem. For $i \in \{0, 1, ..., n-1\}$, migration $i$ migrates switch $s_{i}$ from controller $c_{src_{i}}$ to controller $c_{dst_{i}}$ and incurs a load of $w_{i}$ on the destination controller (and possibly source controller). If $w_{i} > \alpha_{dst_{i}}$ (or $w_{i} > \alpha_{src_{i}}$ when considering failure resiliency) then migration $i$ cannot happen in any round and thus the instance is infeasible. So we will assume $w_{i} \leq \alpha_{dst_{i}}$ (and $w_{i} \leq \alpha_{src_{i}}$ in the case of failure resiliency).

For a QoS group $g_{l}$, $l \in \{0, 1, ..., q - 1\}$, if $g_{l}$ is the empty set we can simply remove it. Otherwise, $g_{l}$ contains at least one migration. If $\beta_{l} = 0$ then none of the migrations in $g_{l}$ can happen in any round and thus again we have an infeasible instance. Thus, we can assume $\beta_{l} \geq 1$ for each $l \in \{0, 1, ..., q - 1\}$.

These requirements are enough to ensure feasibility. To see this, consider the schedule that performs migration $i$ in round $i$ for $i \in \{0, ..., n - 1\}$. Then we let $R = n$ and $x^{r}_{i} = 1$ if $r = i$ and 0 otherwise. So we have

$$\sum_{r=0}^{R-1} x^{r}_{i} = x^{i}_{i} = 1$$

For a round $r \in \{0, 1, ..., n - 1\}$, migration $r$ happens in this round. If $c_{dst_{r}}$ is the destination controller for this migration, then this is the only switch being migrated to this controller in this round and so

$$\sum_{i \in \delta^{in}_{b_{r}}} w_{i}x^{r}_{i} = w_{r}x^{r}_{r} = w_{r} \leq \alpha_{src_{r}}$$

where the last inequality follows from our assumption on the $\alpha$ values. Note that for each migration, the source and destination controllers are distinct. Thus, our solution also satisfies constraint (\ref{eq:controller-extended}) if we are considering failure resiliency. Also, for any controllers other than the source and destination, the sum in the constraint evaluates to 0 as migration $r$ is the only migration in round $r$ and so the constraint is trivially satisfied.

Similarly, for any group $g_{l}$ such that $r \in g_{l}$ then we have that

$$\sum_{i \in g_{l}} x^{r}_{i} = x^{r}_{r} = 1 \leq \beta_{l}$$

where the last inequality follows from our assumption on the $\beta$ values. If $r \notin g_{l}$, then the summation equates to 0 and the constraint is satisfied. 

Thus, this represents a feasible schedule. Moreover, observe that if $r \neq i$ then $r \cdot x^{r}_{i} = 0$. Otherwise, $r \cdot x^{r}_{i} = r$. Thus we have constraints $r \leq \lambda$ for each $r \in \{0, 1, ..., R - 1\}$ so our objective value is $R - 1 = n - 1$. So this solution requires $n$ rounds, the number of migrations.

Note that this solution can be quite far from optimal. To see why, consider an instance with $n$ switches $s_{0}, ..., s_{n-1}$ and $2n$ controllers $c_{0}, ..., c_{2n - 1}$. There are $n$ migrations where migration $i$ migrates switch $s_{i}$ from controller $c_{2i}$ to $c_{2i + 1}$ and incurs a load of $w_{i} = 1$. Moreover, $\alpha_{j} = 1$ $\forall \, j \in \{0, ..., 2n - 1\}$. There are no QoS groups.

In this setting, it is not hard to see that we can schedule all migrations in a single round (the migrations are independent due to the absence of QoS constraints and the fact that each migration is associated with its own source and destination controllers). In contrast, our first solution that schedules each migration in its own round requires $n$ rounds.

Obviously, this is a contrived example to illustrate that there can be a large gap between the simple solution of scheduling each migration in its own round and the optimal solution. In realistic scenarios, it is expected that the migrations would not be independent and their interactions may prevent all migrations from being scheduled in a single round. In order to develop a better lower bound, we will instead consider the LP relaxation. That is for each $r \in \{0, 1, ..., R - 1\}$ and $i \in \{0, 1, ..., n - 1\}$, instead of $x^{r}_{i} \in \{0, 1\}$, we let the $x$ values be real-valued with $0 \leq x^{r}_{i} \leq 1$. Clearly, any solution to the original ILP is also a solution to the LP relaxation and thus the optimal value to this LP gives a valid lower bound.

\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,reference}

% \input{app.tex}
% \input{bio}


% Can use something like this to put references on a page
% by themselves when using endfloat and the captionsoff option.
% \ifCLASSOPTIONcaptionsoff
%   \newpage
% \fi
% that's all folks
\end{document}


