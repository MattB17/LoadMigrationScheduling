\documentclass[letterpaper,12pt,titlepage,oneside,final]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[nottoc]{tocbibind}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{chngcntr}
\usepackage{enumitem}
\usepackage{mathtools}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{subcaption}
\usepackage[ruled,vlined,boxed]{algorithm2e}
\usepackage{lipsum}

\newcommand\bfootnote[1]{%
  \begingroup
  \renewcommand\thefootnote{}\footnote{#1}%
  \addtocounter{footnote}{-1}%
  \endgroup
}

\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}

\let\oldcenter\center
\let\oldendcenter\endcenter
\renewenvironment{center}{\setlength\topsep{0pt}\oldcenter}{\oldendcenter}

\makeatletter
\newsavebox\myboxA
\newsavebox\myboxB
\newlength\mylenA

\newcommand*\xoverline[2][0.75]{%
    \sbox{\myboxA}{$\m@th#2$}%
    \setbox\myboxB\null% Phantom box
    \ht\myboxB=\ht\myboxA%
    \dp\myboxB=\dp\myboxA%
    \wd\myboxB=#1\wd\myboxA% Scale phantom
    \sbox\myboxB{$\m@th\overline{\copy\myboxB}$}%  Overlined phantom
    \setlength\mylenA{\the\wd\myboxA}%   calc width diff
    \addtolength\mylenA{-\the\wd\myboxB}%
    \ifdim\wd\myboxB<\wd\myboxA%
       \rlap{\hskip 0.5\mylenA\usebox\myboxB}{\usebox\myboxA}%
    \else
        \hskip -0.5\mylenA\rlap{\usebox\myboxA}{\hskip 0.5\mylenA\usebox\myboxB}%
    \fi}
\makeatother

\makeatletter
% the contents of \squarecorner were mostly stolen from pgfmoduleshapes.code.tex
\def\squarecorner#1{
    % Calculate x
    %
    % First, is width < minimum width?
    \pgf@x=\the\wd\pgfnodeparttextbox%
    \pgfmathsetlength\pgf@xc{\pgfkeysvalueof{/pgf/inner xsep}}%
    \advance\pgf@x by 2\pgf@xc%
    \pgfmathsetlength\pgf@xb{\pgfkeysvalueof{/pgf/minimum width}}%
    \ifdim\pgf@x<\pgf@xb%
        % yes, too small. Enlarge...
        \pgf@x=\pgf@xb%
    \fi%
    % Calculate y
    %
    % First, is height+depth < minimum height?
    \pgf@y=\ht\pgfnodeparttextbox%
    \advance\pgf@y by\dp\pgfnodeparttextbox%
    \pgfmathsetlength\pgf@yc{\pgfkeysvalueof{/pgf/inner ysep}}%
    \advance\pgf@y by 2\pgf@yc%
    \pgfmathsetlength\pgf@yb{\pgfkeysvalueof{/pgf/minimum height}}%
    \ifdim\pgf@y<\pgf@yb%
        % yes, too small. Enlarge...
        \pgf@y=\pgf@yb%
    \fi%
    %
    % this \ifdim is the actual part that makes the node dimensions square.
    \ifdim\pgf@x<\pgf@y%
        \pgf@x=\pgf@y%
    \else
        \pgf@y=\pgf@x%
    \fi
    %
    % Now, calculate right border: .5\wd\pgfnodeparttextbox + .5 \pgf@x + #1outer sep
    \pgf@x=#1.5\pgf@x%
    \advance\pgf@x by.5\wd\pgfnodeparttextbox%
    \pgfmathsetlength\pgf@xa{\pgfkeysvalueof{/pgf/outer xsep}}%
    \advance\pgf@x by#1\pgf@xa%
    % Now, calculate upper border: .5\ht-.5\dp + .5 \pgf@y + #1outer sep
    \pgf@y=#1.5\pgf@y%
    \advance\pgf@y by-.5\dp\pgfnodeparttextbox%
    \advance\pgf@y by.5\ht\pgfnodeparttextbox%
    \pgfmathsetlength\pgf@ya{\pgfkeysvalueof{/pgf/outer ysep}}%
    \advance\pgf@y by#1\pgf@ya%
}
\makeatother

\pgfdeclareshape{square}{
    \savedanchor\northeast{\squarecorner{}}
    \savedanchor\southwest{\squarecorner{-}}

    \foreach \x in {east,west} \foreach \y in {north,mid,base,south} {
        \inheritanchor[from=rectangle]{\y\space\x}
    }
    \foreach \x in {east,west,north,mid,base,south,center,text} {
        \inheritanchor[from=rectangle]{\x}
    }
    \inheritanchorborder[from=rectangle]
    \inheritbackgroundpath[from=rectangle]
}

\newcommand{\boundellipse}[3]% center, xdim, ydim
{(#1) ellipse (#2 and #3)
}



\title{Migration Scheduling Model}

\newtheorem{theorem}{Theorem}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}

\begin{document}

\pagestyle{empty}
\pagenumbering{arabic}

% The contents of the title page are specified in the "titlepage"
% environment.

% The rest of the front pages should contain no headers and be numbered using Roman numerals starting with `ii'
\pagestyle{plain}

\newpage % Ends the current page and causes all figures and tables that have so far appeared in the input to be printed.
% In a two-sided printing style, it also makes the next page a right-hand (odd-numbered) page, producing a blank page if necessary.

\cleardoublepage

\newpage

\begin{center}
    \Huge{\bf Migration Scheduling Model}
\end{center}

\section{Formulation}

\noindent It is assumed that the migrations take place in a series of discrete rounds. That is, in each round a collection of migrations occur, respecting the controller resource and QoS constraints. Then these migrations are removed from consideration for subsequent rounds. Our goal is to complete all migrations in the minimum number of rounds. We assume that at most $R$ rounds are needed. We discuss later how to find such a value $R$.

To model this, we consider an Integer Linear Program (ILP). It is assumed that we have $m$ controllers $\mathcal{C} = \{c_{0}, ..., c_{m-1}\}$. Controller $c_{j}$ can handle a load of $\alpha_{j}$ per round. In addition, there are $n$ switches $\mathcal{S} = \{s_{0}, ..., s_{n-1}\}$

There are a set of $p$ migrations $\mathcal{M} = \{m_{0}, ..., m_{p-1}\}$. For $k \in \{0, ..., p-1\}$, migration $m_{k}$ migrates switch $s_{j_{k}}$ from controller $c_{a_{k}}$ to $c_{b_{k}}$ where $j_{k} \in \{0, 1, ..., n - 1\}$ and $a_{k}, b_{k} \in \{0, 1, ..., m - 1\}$ with $a_{k} \neq b_{k}$. Moreover, the migration requires $w_{k}$ units of controller resources. 

We add the additional assumption that $s_{j_{0}}, ..., s_{j_{p-1}}$ are all distinct. This excludes the case that we have a switch $s$ that is migrated from controller $a$ to controller $b$ and then later migrated from controller $b$ to controller $c$. Instead, we would just specify a single migration from controller $a$ to $c$. Note, with this constraint, we have that $p \leq n$. For ease of exposition, we can then relabel the switches so that migration $k$ takes place for switch $s_{k}$ and then we can assume $p = n$ (any switch not involved in a migration does not contribute to the model and can thus be removed from consideration).

There are also a set of $q$ groups $\mathcal{G} = \{g_{0}, ..., g_{q-1}\}$. For $l \in \{0, 1, ..., q - 1\}$, group $g_{l}$ is a set of switches associated with a particular QoS constraint such as a specific service or a critical network path. Group $g_{l}$ has a capacity $\beta_{l}$ specifying a limit on the number of switches in $g_{l}$ which can be migrated in one round.

\noindent\textbf{Variables}\newline
\noindent As mentioned previously, we assume we have an upper bound $R$ on the number of rounds required for all migrations. Thus we introduce binary variables $x^{r}_{i}$ for $i \in \{0, 1, ..., n - 1\}$ and $r \in \{0, 1, ..., R - 1\}$ where
\[
    x^{r}_{i} =
    \begin{cases}
        1 &\text{ if migration } i \text { is scheduled in round } r \\
        0 &\text{ otherwise}
    \end{cases}
\]

\noindent\textbf{Constraints}\newline
\noindent Each migration $i \in \{0, 1, ..., n - 1\}$ must take place in exactly one round. $x^{r}_{i}$ is 1 precisely when migration $i$ occurs in round $r \in \{0, 1, ..., R-1\}$ and 0 otherwise. Thus, we have

\begin{equation}\label{eq:single-migration}
    \sum_{r=0}^{R-1} x^{r}_{i} = 1 \hspace{1cm} \forall \, i \in \{0, 1, ..., n - 1\}
\end{equation}

\noindent For a controller $c_{j}$, $j \in \{0, 1, ..., m - 1\}$, let 

$$\delta^{in}_{j} = \{i \, | \, i \in \{0, 1, ..., n-1\}, \, c_{j} \text{ is the destination for migration } i\}$$

That is, $\delta^{in}_{j}$ is the set of migrations that have $c_{j}$ as the destination controller. In any round, the total load on controller $c_{j}$ from migrations cannot exceed $\alpha_{j}$ and if migration $i$ happens in round $r$ it contributes $w_{i}$ towards this load and 0 otherwise. Thus, it contributes $w_{i}x^{r}_{i}$ in round $r$. This gives the following constraint

\begin{equation}\label{eq:controller-simple}
    \sum_{i \, \in \, \delta^{in}_{j}} w_{i}x^{r}_{i} \leq \alpha_{j} \hspace{1cm} \forall \, r \in \{0, ..., R-1\}, \, j \in \{0, ..., m-1\}
\end{equation}

If we want to add failure resiliency, we can also ensure that the load on the source controllers never exceeds their capacity. So we similarly define

$$\delta^{out}_{j} = \{i \, | \, i \in \{0, 1, ..., n-1\}, \, c_{j} \text{ is the source for migration } i\}$$

So $\delta^{out}_{j}$ is the set of migrations that have $c_{j}$ as the source controller. Using the same logic, and updating equation (\ref{eq:controller-simple}) we get

\begin{equation}\label{eq:controller-extended}
    \sum_{i \, \in \, \delta^{out}_{j}} w_{i}x^{r}_{i} + \sum_{i \, \in \, \delta^{in}_{j}} w_{i}x^{r}_{i} \leq \alpha_{j} \hspace{1cm} \forall \, r \in \{0, ..., R-1\}, \, j \in \{0, ..., m-1\}
\end{equation}

Note that for a particular controller $c_{j}$, for any migration $i \in \{0, 1, ..., n-1\}$, $i$ is an element of at most one of $\delta^{out}_{j}$ and $\delta^{in}_{j}$. Thus, the term $w_{i}x^{r}_{i}$ appears at most once in equation (\ref{eq:controller-extended}).

\noindent For a QoS group $g_{l}$, $l \in \{0, 1, ..., q-1\}$, at most $\beta_{l}$ of the migrations in this group can occur in a single round. Using the definition of the $x$ variables we have

\begin{equation}\label{eq:qos-constraint}
    \sum_{i \, \in \, g_{l}} x^{r}_{i} \leq \beta_{l} \hspace{1cm} \forall \, r \in \{0, ..., R - 1\}, \, l \in \{0, ..., q-1\}
\end{equation}

\noindent\textbf{Objective}\newline
We want to minimize the maximum number of rounds to complete all migrations. So consider the quantity $r(x^{r}_{i})$ for any $r \in \{0, ..., R - 1\}$ and $i \in \{0, ..., n - 1\}$. This takes value $r$ when migration $i$ occurs in round $r$ and 0 otherwise. Thus, the quantity we want to minimize is

$$\max_{\substack{0 \leq i \leq n - 1 \\ 0 \leq r \leq R - 1}} r(x^{r}_{i})$$

Unfortunately, this quantity is not linear. In order to linearize it, we introduce a new variable $\lambda$ and introduce the constraints

\begin{equation}\label{eq:max-constraint}
    r(x^{r}_{i}) \leq \lambda \hspace{1cm} \forall \, i \in \{0, ..., n-1\}, \, r \in \{0, ..., R - 1\}
\end{equation}

With these new constraints, our objective simply becomes to minimize $\lambda$.\newline

\noindent\textbf{Model}\newline
\noindent Combining our objective function with the constraints given by (\ref{eq:single-migration}), (\ref{eq:controller-simple}), (\ref{eq:qos-constraint}), (\ref{eq:max-constraint}), and the binary constraints for our variables gives us our ILP model (P).\newline
\newpage

\begin{minipage}{0.8\textwidth}
\begin{center}
    $\min$ $\lambda$
\end{center}
\end{minipage}
\begin{minipage}{0.15\textwidth}
\begin{center}
    ($P$)
\end{center}
\end{minipage}
s.t.
\begin{center}
    \begin{alignat*}{2}
        &\sum_{r=0}^{R-1} x^{r}_{i} = 1 \hspace{2cm} &&\forall \, i \in \{0, ..., n-1\} \\
        &\sum_{i \, \in \, \delta^{in}_{j}} w_{i}x^{r}_{i} \leq \alpha_{j} &&\forall \, r \in \{0, ..., R-1\}, \, j \in \{0, ..., m-1\}\\
        &\sum_{i \, \in \, g_{l}} x^{r}_{i} \leq \beta_{l} &&\forall \, r \in \{0, ..., R-1\}, l\,  \in \{0, ..., q-1\}\\
        &r(x^{r}_{i}) \leq \lambda &&\forall \, i \in \{0, ..., n - 1\}, \, r \in \{0, ..., R - 1\}\\
        &x^{r}_{i} \in \{0, 1\} &&\forall \, i \in \{0, ..., n - 1\}, \, r \in \{0, ..., R - 1\}
    \end{alignat*}
\end{center}

\section{Complexity}
In this section we show the hardness of the migration scheduling problem. Towards that end, consider a graph $G=(V, E)$ where $V$ is the set of vertices and $E$ is the set of edges. 

For any $k \in \mathbb{Z}$, the set $\mathbb{Z}_{k}$ represents the set of integers modulo $k$. That is, $\mathbb{Z}_{k} = \{0, 1, ..., k - 1\}$. A valid $k$-colouring of $G$ is a function $f: V \rightarrow \mathbb{Z}_{k}$ such that for any $u, v \in V$ such that $uv \in E$, $f(u) \neq f(v)$. This corresponds to assigning colours to vertices such that no edge has its two endpoints assigned the same colour. Karp \cite{karp1972reducibility} showed that it is NP-complete to decide whether a given graph $G$ has a $k$-colouring for any $k \geq 3$ (note that graphs with a 1-colouring are an independent set and graphs with a 2-colouring are bipartite).

The chromatic number of $G$, denoted $\chi(G)$ is the minimum $k$ such that $G$ has a $k$-colouring. Note that finding $\chi(G)$ is also NP-complete because if we know $\chi(G)$ then we can answer whether or not $G$ has a $k$-colouring in constant time for any $k \in mathbb{N}$. Given this, we now prove the following.

\begin{theorem}
    The migration scheduling problem is NP-hard.
\end{theorem}
\begin{proof}
    Consider a graph $G = (V, E)$ and suppose we want to determine $\chi(G)$. We will construct a migration scheduling instance as follows. We have 2 controllers, $c_{0}$ and $c_{1}$ as well as $n = |V|$ switches and $n$ migrations. We relabel the vertices so that $V = \{0, 1, ..., n-1\}$ and then vertex $i$ is associated with a switch $s_{i}$ and migration $m_{i}$. Each migration has $c_{0}$ as the source controller and $c_{1}$ as the destination controller and a load of $w_{i} = 1$. Controller $c_{0}$ can accommodate a load of $\alpha_{0} = n$. Similarly, $\alpha_{1} = n$. So in the absence of QoS groups, all migrations can happen in one round.
    
    But now consider an edge $ij \in E$ ($i, j \in \{0, 1, ..., n - 1\}$ with $i \neq j$). We define a QoS group $g_{ij} = \{i, j\}$ with $\beta_{ij} = 1$. That is, there is a QoS group associated with each edge where the group contains the migrations corresponding to the endpoints of the edge. Moreover, $\beta_{ij} = 1$ enforces that the two migrations must complete in different rounds.
    
    This gives $|E|$ QoS groups and we have $|V|$ switches. With the addition of the 2 controllers this gives us a migration scheduling instance which has size $O(|V| + |E|)$.
    
    Now suppose we solve this instance to get an optimal solution $r*$ and define a function $f: V \rightarrow \mathbb{Z}_{r* + 1}$ such that for $i \in V$, $f(i) = r$ if migration $i$ happens in round $r$ with $0 \leq r \leq r*$. Then consider any edge $ij \in E$. Then QoS group $g_{ij}$ ensures that migrations $i$ and $j$ complete in different rounds, say rounds $r_{1}$ and $r_{2}$ with $r_{1} \neq r_{2}$. Then by the definition of $f$ we have $f(i) = r_{1} \neq r_{2} = f(j)$. Thus, the ends of $ij$ receive different colours. As this is true for every edge of $G$, this gives a valid $r* + 1$ colouring of $G$.
    
    Thus $\chi(G) \leq r* + 1$. We claim that $\chi(G) = r* + 1$. To see this, suppose as a contradiction that $\chi(G) < r* + 1$. Then $\exists k \in \mathbb{Z}$ with $k \leq r*$ such that $G$ has a $k$-colouring. Choose such a $k$ colouring $h: V \rightarrow \mathbb{Z}_{k}$. Then consider the following migration schedule: for each migration $i \in \{0, 1, ..., n-1\}$ if $h(i) = r \in \mathbb{Z}_{k}$ then we schedule migration $i$ in round $r$. Then note that all migrations are scheduled within the rounds 0 to $\max_{0 \leq i \leq n-1} h(i) \leq k - 1$. Note that there are $n$ nodes so there are at most $n$ migrations in a single round, meaning the controller capacity constraints are trivially satisfied. Next consider the QoS constraints for a QoS group $g_{ij}$. Then $ij \in E$ and because $h$ is a valid colouring we have that $h(i) \neq h(j)$. So migrations $i$ and $j$ are scheduled in different rounds. That is, at most one migration of $g_{ij}$ is scheduled in each round. As $\beta_{ij} = 1$, the QoS constraints are valid. Thus, we have constructed a valid schedule that completes in at most $k - 1 < r*$ rounds, contradicting the optimality of $r*$.
    
    Thus, we have shown a complete reduction from finding the chromatic number of a graph $G$ to our problem. As determining $\chi(G)$ is NP-complete we have that the migration scheduling problem is NP-hard. 
\end{proof}

\section{Feasibility and Bounds}
\noindent We next consider the feasibility of the migration scheduling problem. For $i \in \{0, 1, ..., n-1\}$, migration $i$ migrates switch $s_{i}$ from controller $c_{a_{i}}$ to controller $c_{b_{i}}$ and incurs a load of $w_{i}$ on the destination controller (and possibly source controller). If $w_{i} > \alpha_{b_{i}}$ (or $w_{i} > \alpha_{a_{i}}$ when considering failure resiliency) then migration $i$ cannot happen in any round and thus the instance is infeasible. So we will assume $w_{i} \leq \alpha_{b_{i}}$ (and $w_{i} \leq alpha_{a_{i}}$ in the case of failure resiliency).

For a QoS group $g_{l}$, $l \in \{0, 1, ..., q - 1\}$, if $g_{l}$ is the empty set we can simply remove it. Otherwise, $g_{l}$ contains at least one migration. If $\beta_{l} = 0$ then none of the migrations in $g_{l}$ can happen in any round and thus again we have an infeasible instance. Thus, we can assume $\beta_{l} \geq 1$ for each $l \in \{0, 1, ..., q - 1\}$.

These requirements are enough to ensure feasibility. To see this, consider the schedule that performs migration $i$ in round $i$ for $i \in \{0, ..., n - 1\}$. Then we let $R = n$ and $x^{r}_{i} = 1$ if $r = i$ and 0 otherwise. So we have

$$\sum_{r=0}^{R-1} x^{r}_{i} = x^{i}_{i} = 1$$

For a round $r \in \{0, 1, ..., n - 1\}$, migration $r$ happens in this round. If $c_{b_{r}}$ is the destination controller for this migration then this is the only switch being migrated to this controller in this round and
so

$$\sum_{i \in \delta^{in}_{b_{r}}} w_{i}x^{r}_{i} = w_{r}x^{r}_{r} = w_{r} \leq \alpha_{b_{r}}$$

where the last inequality follows from our assumption on the $\alpha$ values. Note that for each migration, the source and destination controllers are distinct. Thus, our solution also satisfies constraint (\ref{eq:controller-extended}) if we are considering failure resiliency. Also, for any controllers other than the source and destination, the sum in the constraint evaluates to 0 as migration $r$ is the only migration in round $r$ and so the constraint is trivially satisfied.

Similarly, for any group $g_{l}$ such that $r \in g_{l}$ then we have that

$$\sum_{i \in g_{l}} x^{r}_{i} = x^{r}_{r} = 1 \leq \beta_{l}$$

where the last inequality follows from our assumption on the $\beta$ values. If $r \notin g_{l}$, then the summation equates to 0 and the constraint is satisfied. 

Thus, this represents a feasible schedule. Moreover, observe that if $r \neq i$ then $r(x^{r}_{i}) = 0$. Otherwise, $r(x^{r}_{i}) = r$. Thus we have constraints $r \leq \lambda$ for each $r \in \{0, 1, ..., R - 1\}$ so our objective value is $R - 1 = n - 1$. So this solution requires $n$ rounds, the number of migrations.

Note that this solution can be quite far from optimal. To see why, consider an instance with $n$ switches $s_{0}, ..., s_{n-1}$ and $2n$ controllers $c_{0}, ..., c_{2n - 1}$. There are $n$ migrations where migration $i$ migrates switch $s_{i}$ from controller $c_{2i}$ to $c_{2i + 1}$ and incurs a load of $w_{i} = 1$. Moreover, $\alpha_{j} = 1$ $\forall \, j \in \{0, ..., 2n - 1\}$. There are no QoS groups.

In this setting, it is not hard to see that we can schedule all migrations in a single round (the migrations are independent due to the absence of QoS constraints and the fact that each migration is associated with its own source and destination controllers). In contrast, our first solution that schedules each migration in its own round requires $n$ rounds.

Obviously, this is a contrived example to illustrate that there can be a large gap between the simple solution of scheduling each migration in its own round and the optimal solution. In realistic scenarios, it is expected that the migrations would not be independent and their interactions may prevent all migrations from being scheduled in a single round. In order to develop a better lower bound, we will instead consider the LP relaxation. That is for each $r \in \{0, 1, ..., R - 1\}$ and $i \in \{0, 1, ..., n - 1\}$, instead of $x^{r}_{i} \in \{0, 1\}$, we let the $x$ values be real-valued with $0 \leq x^{r}_{i} \leq 1$. Clearly, any solution to the original ILP is also a solution to the LP relaxation and thus the optimal value to this LP gives a valid lower bound.
 
\newpage

\bibliographystyle{abbrv}
\bibliography{model.bib}


\end{document}